#!/usr/bin/python

CONFIG_FILE = "/etc/soton/drone.conf"
BASE_DIR    = "/etc/soton"
VERSION     = "2019-01-04-01"
ANSI_BOLD   = "\033[1m"
ANSI_RESET  = "\033[0;0m"

import os
import sys
import argparse
import subprocess
import ConfigParser
import datetime
import requests
import re
import platform
import getpass
import time
import json
import yaml
import dmidecode
import fcntl
import logging

class DroneAgent:

	############################################################################

	def fatal(self,message):
		sys.stderr.write("ERROR: " + message + "\n")
		sys.exit(1)

	def fatalex(self,message,exception):
		sys.stderr.write("ERROR: " + message + " - " + str(type(exception)) + " " + str(exception) + "\n")
		sys.exit(1)

	############################################################################

	def warn(self,message):
		sys.stderr.write("WARN: " + message + "\n")

	def warnex(self,message,exception):
		sys.stderr.write("WARN: " + message + " - " + str(type(exception)) + " " + str(exception) + "\n")

	############################################################################

	def print_debug(self,message):
		if self.debug:
			sys.stderr.write("DEBUG: " + message + "\n")

	def print_verbose(self,message):
		if self.verbose:
			print message

	############################################################################

	def strtime(self,when=None):
		if when is None:
			dt = datetime.datetime.utcnow()
		else:
			dt = datetime.datetime.utcfromtimestamp(int(when))

		return dt.strftime("%Y-%m-%d %H:%M:%S")

	############################################################################

	def get_config(self):
		self.config = ConfigParser.RawConfigParser()

		## Set up default sections
		self.config.add_section('backup')
		self.config.add_section('puppet')
		self.config.add_section('server')
		self.config.add_section('ssh')
		self.config.add_section('reskit')
		self.config.add_section('csw')
		self.config.add_section('update')
	
		## Set up default values
		self.config.set('backup','user','backup')
		self.config.set('backup','server','localhost')
		self.config.set('backup','rsyncd_port','873')
		self.config.set('backup','port','9999')
		self.config.set('backup','vgname','sysvg')
		self.config.set('backup','lv_source_name','home')
		self.config.set('backup','lv_snap_name','homesnap')
		self.config.set('backup','lv_snap_mount','/mnt/homesnap')
		self.config.set('backup','enable_fallback','true')
		self.config.set('backup','fallback_bind','/home')
		self.config.set('backup','enabled','true')

		self.config.set('puppet','user','puppet')
		self.config.set('puppet','binary','/opt/puppetlabs/bin/puppet')
		self.config.set('puppet','server','localhost')
		self.config.set('puppet','manifest','site')

		self.config.set('reskit','pkgdir','/etc/reskit/packages/')
		self.config.set('reskit','server','localhost')
		self.config.set('reskit','share','reskit')

		self.config.set('csw','server','localhost')

		self.config.set('update','pkcon_binary','/bin/pkcon')

		self.config.set('ssh','binary','/usr/bin/ssh')

		self.config.set('server','api_key','unset')

		try:
			self.config.read(CONFIG_FILE)
		except Exception as ex:
			self.fatalex("Could not read the config file " + CONFIG_FILE,ex)

	############################################################################

	def sysexec(self,command,shell=False):
		if self.debug:
			if type(command) is list:
				print "DEBUG: Executing command " + str(" ".join(command))
			else:
				print "DEBUG: Executing command " + str(command)

		try:
			proc = subprocess.Popen(command,stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=shell,close_fds=True)
			(stdoutdata, stderrdata) = proc.communicate()
			if stdoutdata is None:
				stdoutdata = ""

			if self.debug:
				print "DEBUG: return code: " + str(proc.returncode)
				if len(stdoutdata) > 0:
					print "DEBUG-BEGIN"
					sys.stdout.write(stdoutdata)
					print "DEBUG-END"
			
			return (proc.returncode,str(stdoutdata))
		except Exception as ex:
			return (1,str(type(ex)) + " " + str(ex))

	############################################################################

	def is_network_up(self,timeout=30,exit_if_down=False):
		if self.args.nmignore:
			print_debug("skipping network test because -i was specified")
			return True

		self.print_verbose('checking network status')

		(code,output) = self.sysexec(['/usr/bin/nm-online', '-q', '--timeout=' + str(timeout)])
	
		if code == 0:
			self.print_verbose("network manager reports the network is up")
			return True
		else:
			if exit_if_down:
				self.print_verbose("network manager reports the network is down, exiting")
				sys.exit(254)
			else:
				self.print_verbose("network manager reports the network is down")
				return False

	############################################################################
	############################################################################

	def puppet_sync(self):
		self.is_network_up(exit_if_down=True)

		self.print_verbose('starting sync')

		(code, output) = self.sysexec(['/usr/bin/rsync', '-e', 'ssh -i ' + str(BASE_DIR) + '/ssh_private_key -o PreferredAuthentications=publickey -oStrictHostKeyChecking=no', '-av', '--delete', self.config.get('puppet','user') + '@' + self.config.get('puppet','server') + ':', str(BASE_DIR) + '/puppet/'])

		if code != 0:
			self.fatal("sync failed: \n" + output)
		else:
			self.print_verbose("sync complete")

	############################################################################

	def puppet_apply(self):
		self.print_verbose('starting puppet apply')

		(code, output) = self.sysexec([self.config.get('puppet','binary'), 'apply', '--detailed-exitcodes', '--modulepath', str(BASE_DIR) + '/puppet/modules/', str(BASE_DIR) + '/puppet/manifests/' + self.config.get('puppet','manifest') + '.pp'])

		uts = int(time.time())
		when = "puppet apply last ran at " + self.strtime() + "\n"

		if code == 0:
			status = "system complies with policy, no changes were required"
			self.print_verbose(status)
		elif code == 2:
			status = "system complies with policy, changes made to system:"
			status = status + "\n" + output
			self.print_verbose(status)

		else:
			status = "apply failed: \n" + output
			self.puppet_save_state(uts,code,output)
			self.fatal(status)

		self.puppet_save_state(uts,code,output)

	############################################################################

	def puppet_save_state(self,uts,code,output):
		data = {'when': uts, 'code': code, 'output': output}

		try:
			if not os.path.exists(BASE_DIR + "/state"):
				os.mkdir(BASE_DIR + "/state")
		except Exception as ex:
			self.warn("Could not create directory " + BASE_DIR + "/state - unable to save puppet status")
			return

		try:
			with open(BASE_DIR + "/state/puppet","w") as fp:
				json.dump(data,fp)
		except Exception as ex:
			self.warnex("Could not write to " + BASE_DIR + "/state/puppet",ex)

	############################################################################

	def puppet_get_state(self):
		status_file = BASE_DIR + "/state/puppet" 

		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					data = json.load(fp)
			except Exception as ex:
				self.fatalex("Could not read from puppet status file " + status_file,ex)

			try:
				print "the last puppet apply finished at " + self.strtime(data['when'])

				if data['code'] == 0:
					print "system was in compliance with the system policy"
				elif data['code'] == 2:
					print "changes were made to the system to comply with the system policy:"
					print data['output'].rstrip("\n")
				else:
					print "the attempt to apply the system policy failed:"
					print data['output'].rstrip("\n")

			except Exception as ex:
				self.fatalex("Could not load puppet status",ex)

		else:
			print "puppet apply has never been run on this system"

	############################################################################

	def puppet_facts(self):

		(code, output) = self.sysexec([self.config.get('puppet','binary'), 'facts', 'find', '--modulepath', str(BASE_DIR) + '/puppet/modules/'])

		if code == 0:
			print output
		else:
			self.fatal("Could not retrieve facts: \n" + output)

	############################################################################

	def puppet(self):
		if self.action == 'sync':
			self.puppet_sync()

		elif self.action == "apply":
			self.puppet_apply()

		elif self.action == "run":
			self.puppet_sync()
			self.puppet_apply()

		elif self.action == "status":
			self.puppet_get_state()

		elif self.action == "facts":
			self.puppet_facts()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################
	############################################################################

	def get_backup_lock(self):
		## Check the state directory exists, and if it doesnt, create it
		self.print_debug("Checking the state directory exists")
		try:
			if not os.path.exists(BASE_DIR + "/state"):
				os.mkdir(BASE_DIR + "/state")
		except Exception as ex:
			self.fatalex("Could not create directory " + BASE_DIR + "/state",ex)

		## Mark that a backup is in progress
		self.print_debug("Checking the backup state file exists")
		try:
			if not os.path.exists(BASE_DIR + "/state/backup"):
				self.print_debug("creating the backup state file")
				with open(BASE_DIR + "/state/backup","w") as fp:
					fp.write("")
		except Exception as ex:
			self.fatalex("Could not create backup state file " + BASE_DIR + "/state/backup",ex)

		## Open the lock the file
		self.print_debug("opening the backup state file for locking")
		try:
			fd = open(BASE_DIR + "/state/backup","w")
		except Exception as ex:
			self.fatalex("Could not open backup state file " + BASE_DIR + "/state/backup",ex)

		## Try to lock
		self.print_debug("attempting to lock the backup state file")
		try:
			fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
		except IOError as ex:
			# we don't error here, as a backup already in progress isnt an
			# error as such, it just means we don't need to run a backup again.
			print "a backup is already in progress, please try again later"
			sys.exit(0)
		except Exception as ex:
			self.fatalex("unable to lock the backup state file",ex)

		## Write out the status that a backup is in progress
		self.print_debug("writing out the in-progress state to the backup state file")
		try:
			json.dump({'when': int(time.time()), 'code': -3, 'output': 'backup in progress'},fd)
			fd.truncate()
			fd.flush()
		except Exception as ex:
			self.warnex("unable to save to the backup state file",ex)

		return fd

	############################################################################
	############################################################################

	def backup_now(self):
		bLock = self.get_backup_lock()

		if not self.config.getboolean("backup","enabled"):
			self.print_verbose("backups are disabled on this system")
			self.backup_save_state(bLock,-4,"Backup is disabled on this system")
			return

		if not self.is_network_up():
			self.print_verbose("network is down, not running backup")
			self.backup_save_state(bLock,-2,"The network is down, cannot run backup")
			return

		self.print_verbose("starting backup (this may take several minutes)")

		## Ensure the mount point for the snapshot exists
		self.print_debug("checking config.backup.lv_snap_mount path")
		if not os.path.exists(self.config.get('backup','lv_snap_mount')):
			self.backup_save_state(bLock,-1,"The lv_snap_mount directory does not exist")
			self.fatal("The lv_snap_mount directory - " + self.config.get('backup','lv_snap_mount') + " - does not exist")

		## Check to see if homesnap is already mounted, and if it is, unmount it
		self.print_debug("checking to see if the snapshot is already mounted")
		mounted = False
		try:
			with open("/proc/mounts","r") as mfp:
				mounts = mfp.readlines()
		except Exception as ex:
			if self.verbose:
				self.warnex("Could not check if the snapshot is already mounted",ex)

		for line in mounts:
			if self.config.get('backup','lv_snap_mount') in line:
				mounted = True

		if mounted:
			self.print_debug("unmounting existing mounted snapshot")
			(code, output) = self.sysexec(['/bin/umount', self.config.get('backup','lv_snap_mount')])

			if code == 0:
				self.print_verbose("existing stale snapshot unmounted")
			else:
				self.warn("Could not unmount existing stale snapshot, backup will fail:\n" + output)

		## Check to see if the logical volume snapshot already exists, and if it is, delete it
		self.print_debug("checking to see if the snapshot lv already exists")
		(code, output) = self.sysexec(['/sbin/lvdisplay', '%s/%s' % (self.config.get('backup','vgname'),self.config.get('backup','lv_snap_name'))])

		if code == 0:
			self.print_debug("deleting stale lv snapshot")
			(code, output) = self.sysexec(['/sbin/lvremove', '-f', '%s/%s' % (self.config.get('backup','vgname'), self.config.get('backup','lv_snap_name'))])

			if code == 0:
				self.print_verbose("existing stale snapshot removed")
			else:
				self.warn("Could not delete stale snapshot, backup will fail:\n" + output)

		## Create the snapshot of home
		self.print_debug("creating snapshot")
		(code, output) = self.sysexec(['/sbin/lvcreate', '-n', self.config.get('backup','lv_snap_name'), '-kn', '-s', '%s/%s' % (self.config.get('backup','vgname'), self.config.get('backup','lv_source_name'))])

		if code == 0:
			self.print_verbose("snapshot created")
			snapshot_failed = False
		else:
			snapshot_failed = True

		if snapshot_failed:
			## If fallback is enabled, then attempt that, otherwise fail the backup
			if self.config.getboolean('backup','enable_fallback'):
				## In the event the snapshot fails, we fall back to bind mounting onto lv_snap_mount
				## so that we can still perform a backup (even if some files will inevitably be locked or
				## changed in flight)
				self.warn("Could not create disk snapshot: \n" + output)
				self.warn("Falling back to bind mount")

				## Mount /home as a bind mount on to our lv_snap_mount path
				self.print_debug("bind mounting %s" % (self.config.get('backup','fallback_bind'),))
				(code, output) = self.sysexec(['/bin/mount', '-o', 'ro', '--bind', self.config.get('backup','fallback_bind'), self.config.get('backup','lv_snap_mount')])

				if code == 0:
					self.print_verbose("bind mount successful")
				else:
					self.backup_save_state(bLock,-1,"Could not do bind mount: \n" + output)
					self.fatal("Could not do bind mount:\n" + output)
			else:
				self.backup_save_state(bLock,-1,"Could not create disk snapshot: \n" + output)
				self.fatal("Could not create snapshot:\n" + output)
		else:
			## Snapshot created successfully, mount it
			self.print_debug("mounting snapshot")
			(code, output) = self.sysexec(['/bin/mount', '-o', 'ro,nouuid', '/dev/mapper/%s-%s' % (self.config.get('backup','vgname'), self.config.get('backup','lv_snap_name')), self.config.get('backup','lv_snap_mount')])
	
			if code == 0:
				self.print_verbose("snapshot mounted")
			else:
				self.backup_save_state(bLock,-1,"Could not mount disk snapshot: \n" + output)
				self.fatal("Could not mount snapshot:\n" + output)

		## k we're ready! start the backup!
		(code, output) = self.sysexec([self.config.get('ssh','binary'), '%s@%s' % (self.config.get('backup','user'), self.config.get('backup','server')), '-i', str(BASE_DIR) + '/ssh_private_key', '-o', 'ExitOnForwardFailure yes', '-R', '%s:localhost:%s' % (self.config.get('backup','port'),self.config.get('backup','rsyncd_port'))])

		fail = False
		backup_code = code
		if backup_code == 0:
			status = "backup complete, all files backed up"
			backup_output = ""
		elif code == 1:
			status = "backup partially complete, some files did not backup"
			backup_output = ""
		else:
			fail = True # we use this later to exit with an error
			status = "backup failed"
			backup_output = output

		self.print_verbose(status)

		self.print_debug("unmounting backup source")
		## Now we umount the snapshot and delete it as we don't need it anymore
		(code, output) = self.sysexec(['/bin/umount', self.config.get('backup','lv_snap_mount')])

		if code == 0:
			self.print_verbose("backup source unmounted")
		else:
			self.warn("Could not unmount backup source:\n" + output)

		## Delete the snapshot of home
		if not snapshot_failed:
			self.print_debug("removing snapshot")
			(code, output) = self.sysexec(['/sbin/lvremove', '-f', '%s/%s' % (self.config.get('backup','vgname'), self.config.get('backup','lv_snap_name'))])

			if code == 0:
				self.print_verbose("snapshot removed")
			else:
				self.warn("Could not delete snapshot:\n" + output)

		## Save the final state, and unlock the lock
		self.backup_save_state(bLock,backup_code,backup_output)

		# fatal exit if the backup failed
		if fail:
			self.fatal(status)

	############################################################################

	def backup_save_state(self,bLock,code,output=None):
		data = {'when': int(time.time()), 'code': code, 'output': output}

		## Try to write to the backup status file
		try:
			bLock.seek(0)
			json.dump(data,bLock)
			bLock.truncate()
		except Exception as ex:
			self.warnex("Could not write to " + BASE_DIR + "/state/backup",ex)

		## Try to unlock and close
		try:
			fcntl.flock(bLock, fcntl.LOCK_UN)
			bLock.close()
		except Exception as ex:
			self.warnex("Could not unlock the backup status file",ex)

		## we should tell the server the state, if we can
		self.print_debug("Sending the backup status to the LDI server")

		hostname = platform.node()
		api_key = self.config.get('server','api_key')
		server_url = self.config.get('server','address')
		if not server_url.endswith("/"):
			server_url = server_url + "/"
		server_url = server_url + "api/v1/update/status"

		## Tell the server via a POST 
		self.print_debug("POSTing to " + server_url + " with hostname " + hostname)
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'type': 'backup', 'data': json.dumps(data)}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex("Unable to contact LDI server",ex)

		self.print_debug("return code " + str(r.status_code))

		if r.status_code == 200:
			self.print_debug("LDI server accepted the backup status update")
		else:
			self.print_debug("Unable to update LDI server due to an unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def backup_load_state(self):
		status_file = BASE_DIR + "/state/backup" 

		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					data = json.load(fp)
			except Exception as ex:
				self.fatalex("Could not read from backup status file " + status_file,ex)

			try:
				code = data['code']
				when = data['when']
				if 'output' in data:
					output = data['output']
				else:
					output = None
			except Exception as ex:
				self.fatalex("Could not load backup status",ex)

		else:
			code   = None
			when   = None
			output = None

		return (code,when,output)

	############################################################################

	def backup_get_state(self):

		## mark if backups are enabled or disabled
		if self.config.getboolean("backup","enabled"):
			print "backups are enabled"
		else:
			print "backups are disabled"
			return

		(code,when,output) = self.backup_load_state()

		if code is not None:

			if code == -3:
				print "a backup is currently in progress"
				print "the backup began at " + self.strtime(when)
				return

			print "the last backup attempt was made at " + self.strtime(when)

			if code == 0:
				print "the last backup competed successfully, all files were backed up"
			elif code == 1:
				print "the last backup completed but some files could not be backed up"
			else:
				print "the last backup failed"
				if output is not None:
					print output

		else:
			print "a backup has never been run on this system"

	############################################################################

	def backup_ifneeded(self):
		self.print_debug("checking for last backup")
		(code,when,output) = self.backup_load_state()

		if code is None:
			self.print_verbose("no backup status found, triggering backup")
			self.backup_now()
		else:
			last = datetime.datetime.utcfromtimestamp(int(when))

			if (datetime.datetime.utcnow() - last) > datetime.timedelta(hours=12):
				self.print_verbose("backup is required, triggering backup")
				self.backup_now()
			elif (code != 0):
				self.print_verbose("backup is required, triggering backup")
				self.backup_now()
			else:
				self.print_verbose("backup is not required")

	############################################################################

	def backup_enable(self):
		self.config.set("backup","enabled","yes")
		self.print_debug("Saving the drone config file " + BASE_DIR + "/drone.conf")
		try:
			with open(BASE_DIR + '/drone.conf', 'w') as f:
				self.config.write(f)
		except Exception as ex:
			self.fatalex("Failed to write to " + BASE_DIR + "/drone.conf",ex)

		self.print_verbose("Backups set to enabled")

	############################################################################

	def backup_disable(self):
		self.config.set("backup","enabled","no")
		self.print_debug("Saving the drone config file " + BASE_DIR + "/drone.conf")
		try:
			with open(BASE_DIR + '/drone.conf', 'w') as f:
				self.config.write(f)
		except Exception as ex:
			self.fatalex("Failed to write to " + BASE_DIR + "/drone.conf",ex)

		self.print_verbose("Backups set to disabled")

	############################################################################

	def backup(self):
		if self.action == 'now':
			self.backup_now()

		elif self.action == "status":
			self.backup_get_state()

		elif self.action == "ifneeded":
			self.backup_ifneeded()

		elif self.action == "enable":
			self.backup_enable()

		elif self.action == "disable":
			self.backup_disable()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################
	############################################################################

	def update_trigger(self):
		self.print_verbose("downloading package updates")
		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "--only-download", "update"])

		if code == 0:
			self.print_verbose("package updates downloaded")
		else:
			self.fatal("Could not download package updates:\n" + output)

		if not os.path.exists("/system-update"):
			self.print_debug("the /system-update trigger is absent")
			self.print_verbose("triggering offline update")
			(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-trigger"])

			if code == 0:
				self.print_verbose("the system will update at the next reboot")
			else:
				self.fatal("Could not trigger the offline update:\n" + output)
		else:
			self.print_debug("the /system-update trigger is already present")
			self.print_verbose("the system will update at the next reboot")

	############################################################################

	def update_status(self):
		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-get-prepared"])
		print output.rstrip("\n")

	############################################################################

	def update_history(self):
		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-status"])
		print output.rstrip("\n")

	############################################################################

	def update(self):
		if self.action == 'status':
			self.update_status()

		elif self.action == 'history':
			self.update_history()

		elif self.action == "trigger":
			self.update_trigger()

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################
	############################################################################

	def reskit_update_package(self,package):
		self.print_verbose("starting update of '" + package + "'")

		reskit_pkgdir  = self.config.get('reskit','pkgdir')
		reskit_server  = self.config.get('reskit','server')
		reskit_share   = self.config.get('reskit','share')

		package_file = os.path.join(reskit_pkgdir,package)

		## Open the reskit package file
		## this is a yaml formatted file with
		## two variables - source and dest (for rsync)
		try:
			self.print_debug("opening file '" + package_file + "'")
			with open(package_file,"r") as fp:
				package_data = yaml.safe_load(fp)
		except Exception as ex:
			if self.verbose: self.warnex("Could not read package metadata from '" + package_file + "'",ex)
			return

		try:
			package_source = package_data['src']
			package_dest   = package_data['dest']
			package_delete = True

			if 'delete' in package_data:
				if package_data['delete'] == False:
					package_delete = False
				elif package_data['delete'] in ["False","false","no","NO"]:
					package_delete = False

		except Exception as ex:
			if self.verbose: self.warnex("Invalid/incorrect metadata in '" + package_file + "'",ex)
			return

		if package_delete:
			cmd = ['/usr/bin/rsync', '-av', '--delete']
		else:
			cmd = ['/usr/bin/rsync', '-av']

		cmd.append('rsync://%s/%s/%s' % (reskit_server, reskit_share, package_source))
		cmd.append(package_dest)

		(code, output) = self.sysexec(cmd)

		if code != 0:
			self.print_verbose("reskit update of '" + package + "' failed: \n" + output)
		else:
			self.print_verbose("reskit update of '" + package + "' complete")

	############################################################################

	def reskit_update(self):
		self.is_network_up(exit_if_down=True)

		self.print_verbose("starting reskit update (this may take several minutes)")

		reskit_pkg_dir = self.config.get('reskit','pkgdir')

		self.print_debug("checking config.reskit.pkgdir")
		if not os.path.exists(reskit_pkg_dir):
			self.fatal("The reskit pkgdir directory - " + reskit_pkg_dir + " - does not exist")
		if not os.path.isdir(reskit_pkg_dir):
			self.fatal("The reskit pkgdir path - " + reskit_pkg_dir + " - is not a directory")

		reskit_files = [f for f in os.listdir(reskit_pkg_dir) if os.path.isfile(os.path.join(reskit_pkg_dir, f))]

		package_name = self.args.subaction
		if package_name is None:
			for f in reskit_files:
				try:
					self.reskit_update_package(f)
				except Exception as ex:
					if self.verbose: self.warnex("Failed to run reskit update on " + f,ex)
		else:
			self.print_debug("user asked to update specific package '" + package_name + "'")

			if package_name in reskit_files:
				self.reskit_update_package(package_name)
			else:
				self.fatal("Package '" + package_name + "' not found")

		self.print_verbose("reskit update complete")

	############################################################################

	def reskit_list(self):
		reskit_pkg_dir = self.config.get('reskit','pkgdir')

		self.print_debug("checking config.reskit.pkgdir")
		if not os.path.exists(reskit_pkg_dir):
			self.fatal("The reskit pkgdir directory - " + reskit_pkg_dir + " - does not exist")
		if not os.path.isdir(reskit_pkg_dir):
			self.fatal("The reskit pkgdir path - " + reskit_pkg_dir + " - is not a directory")

		reskit_files = [f for f in os.listdir(reskit_pkg_dir) if os.path.isfile(os.path.join(reskit_pkg_dir, f))]

		for f in reskit_files:
			print f

	############################################################################

	def reskit(self):
		if self.action == 'update':
			self.reskit_update()
		elif self.action == 'list':
			self.reskit_list()
		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################
	############################################################################

	def system_register(self):
		self.is_network_up(exit_if_down=True)

		## work out OS version
		(distname, distversion, distid) = platform.linux_distribution()

		if distid == 'Maipo':
			ident = 'rhel7'
			self.print_verbose("Detected operating system as RHEL/CentOS 7: " + distname + " " + distversion + " " + distid)
		else:
			self.fatal("Your operating system is not supported. Detected as: " + distname + " " + distversion + " " + distid)
			return False

		## Now get the hostname
		register_hostname = platform.node()
		self.print_verbose("Detected hostname as " + register_hostname)

		if not re.match(r"^(uos|iss|lnx|UOS|ISS|LNX)\-[0-9]{2,8}$",register_hostname):
			self.fatal("The hostname of this machine is invalid. It must be of the form uos-<number>")

		register_username = raw_input("Username: ")
		register_password = getpass.getpass()

		server_url = self.config.get('server','address')

		# Ensure trailing slash on the server register URL
		if not server_url.endswith("/"):
			server_url = server_url + "/"

		register_url = server_url + "api/v1/register"

		if self.debug: 
			if self.config.getboolean('server','verify'):
				print "SSL certificate verification enabled"
			else:
				print "SSL certificate verification disabled"

		self.print_verbose("Registering with API endpoint " + register_url)

		try:
			payload = {'ident': ident, 'hostname': register_hostname, 'username': register_username, 'password': register_password}
			r = requests.post(register_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex("Unable to contact registration server",ex)

		self.print_debug("return code " + str(r.status_code))

		if r.status_code == 200:
			try:
				json = r.json()

				if 'error' in json:
					self.fatal("registration server returned an error: " + json['reason'])

				else:
					self.print_verbose("Registration server accepted our request")

			except Exception as ex:
				self.fatalex("failed to parse reponse from registration server",ex)

		else:
			self.fatal("unexpected HTTP return code from server: " + str(r.status_code))

		# Save the SSH public key
		self.print_debug("Saving SSH public key to " + BASE_DIR + "/ssh_public_key")
		try:
			with open(BASE_DIR + '/ssh_public_key', 'w') as f:
				f.write(json['public_key'])
				f.write("\n")
		except Exception as ex:
			self.fatalex("Failed to write to " + BASE_DIR + "/ssh_public_key",ex)

		self.print_verbose("Saved SSH public key to " + BASE_DIR + "/ssh_public_key")

		# Save the SSH private key
		self.print_debug("Saving SSH private key to " + BASE_DIR + "/ssh_private_key")
		try:
			with open(BASE_DIR + '/ssh_private_key', 'w') as f:
				f.write(json['private_key'])
		except Exception as ex:
			self.fatalex("Failed to write to " + BASE_DIR + "/ssh_private_key",ex)

		self.print_verbose("Saved SSH private key to " + BASE_DIR + "/ssh_private_key")

		# Set perms on the key
		self.print_debug("Setting permissions on " + BASE_DIR + "/ssh_private_key")
		try:
			os.chmod(BASE_DIR + '/ssh_private_key', 0600)
		except Exception as ex:
			self.fatalex("Failed to set the permissions of " + BASE_DIR + "/ssh_private_key",ex)

		self.print_verbose("Set permissions on " + BASE_DIR + "/ssh_private_key")

		# Save the backup key (for rsyncd)
		self.print_debug("Saving the backup key to " + BASE_DIR + "/backup_key")
		try:
			with open(BASE_DIR + '/backup_key', 'w') as f:
				f.write("backup:" + json['backup_key'] + "\n")
		except Exception as ex:
			self.fatalex("Failed to write to " + BASE_DIR + "/backup_key",ex)

		self.print_verbose("Saved backup key to " + BASE_DIR + "/backup_key")

		# Set perms on the key
		self.print_debug("Setting permissions on " + BASE_DIR + "/backup_key")
		try:
			os.chmod(BASE_DIR + '/backup_key', 0600)

		except Exception as ex:
			self.fatalex("Failed to set the permissions of " + BASE_DIR + "/backup_key",ex)

		self.print_verbose("Set permissions on " + BASE_DIR + "/backup_key")

		## Merge the new settings into the existing config
		self.config.set('backup','port',json['backup_port'])
		self.config.set('server','api_key',json['api_key'])

		self.print_debug("Saving changes to the drone config file " + BASE_DIR + "/drone.conf")
		try:
			with open(BASE_DIR + '/drone.conf', 'w') as f:
				self.config.write(f)
		except Exception as ex:
			self.fatalex("Failed to write to " + BASE_DIR + "/drone.conf",ex)

		self.print_verbose("Saved drone configuration to " + BASE_DIR + "/drone.conf")

		# Set perms on the drone config
		self.print_debug("Setting permissions on " + BASE_DIR + "/drone.conf")
		try:
			os.chmod(BASE_DIR + '/drone.conf', 0600)
		except Exception as ex:
			self.fatalex("Failed to set the permissions of " + BASE_DIR + "/drone.conf",ex)

		print "Registration completed successfully"

		self.print_verbose("Updating system information and status")

		self.ldi_metadata(register_hostname,json['api_key'],server_url)
		self.ldi_facts(register_hostname,json['api_key'],server_url)

	############################################################################

	def system_status(self):
		print ANSI_BOLD + "backup status:" + ANSI_RESET
		self.backup_get_state()
		print ANSI_BOLD + "\npuppet status:" + ANSI_RESET
		self.puppet_get_state()
		print ANSI_BOLD + "\nupdate status:" + ANSI_RESET
		self.update_status()

	############################################################################
	
	def system_get_gpu(self):
		# NOTE this assumes just one VGA card is visible in lspci, and thus
		# outputs the first one in the list. Its VERY rare that a system would
		# have /two/ graphics cards the OS can utilise.

		try:
			re_vga = re.compile(r'^[0-9a-f]+:[0-9a-f]+\.[0-9a-f]+\s+VGA\s+compatible\s+controller:\s+(.*)')

			(code,output) = self.sysexec(['/usr/sbin/lspci'])
		
			cards = []
			for line in output.splitlines():
				vga_match = re_vga.search(line)
				if vga_match is not None:
					cards.append(vga_match.group(1))

			if len(cards) >= 0:
				return cards[0]
			else:
				return "No GPU found"
		except Exception as ex:
			return "Could not determine GPU"

	############################################################################

	def system_get_mem(self):
		try:
			total = 0
			for mem in dmidecode.memory().values():
				if 'Form Factor' in mem['data']:
					if mem['data']['Form Factor'] in ['DIMM','SODIMM']:
						if 'Size' in mem['data'] and mem['data']['Size'] is not None:
							parts = mem['data']['Size'].split(' ')
							number = parts[0]
							unit = parts[1]

							# Store size in bytes
							if unit == 'KB' or unit == 'KiB':
								size = int(number) * 1024
							elif unit == 'MB' or unit == 'MiB':
								size = int(number) * 1048576
							elif unit == 'GB' or unit == 'GiB':
								size = int(number) * 1073741824
							elif unit == 'TB' or unit == 'TiB':
								size = int(number) * 1099511627776
							else:
								size = int(number)

							total = total + size

			human = str(total) + " bytes"
			if total > 1073741824:
				human = str(total / 1024 / 1024 / 1024) + " GB"
			elif total > 1048576:
				human = str(total / 1024 / 1024) + " MB"
			elif total > 1024:
				human = str(total / 1024) + " KB"

			return (total,human)
		except Exception as ex:
			return (0,"Could not determine physical memory")

	############################################################################

	def system_get_cpu(self):
		try:

			re_processor = re.compile(r'^processor\s*:\s+([0-9]+)')
			re_physical_id = re.compile(r'^physical\sid\s*:\s+([0-9]+)')
			re_cpu_cores = re.compile(r'^cpu\scores\s*:\s+([0-9]+)')
			re_model_name = re.compile(r'^model\sname\s*:\s+(.*)')
			re_cache_size = re.compile(r'^cache\ssize\s*:\s+(.*)')

			# Setup
			processor = None
			cpu = None
			cpu_cores = None
			model = None
			cache_size = None
			procs = {}

			# Read the entire cpuinfo file
			cpuinfo = open('/proc/cpuinfo', 'r')
			for line in cpuinfo:
				# Match the line against our regexs
				p_match     = re_processor.search(line)
				pid_match   = re_physical_id.search(line)
				cpu_match   = re_cpu_cores.search(line)
				model_match = re_model_name.search(line)
				cache_match = re_cache_size.search(line)

				if p_match is not None:
					# We're starting a new CPU, record the old one
					if cpu is not None and cpu not in procs:
						procs[cpu] = { 'model': model, 'cores': cpu_cores, 'cache': cache_size }
				
					#processor = int(p_match.group(1))
					cpu = None
					cpu_core = None
					model = None

				if pid_match is not None:
					cpu = int(pid_match.group(1))

				if cpu_match is not None:
					cpu_cores = int(cpu_match.group(1))

				if model_match is not None:
					model = model_match.group(1)

				if cache_match is not None:
					cache_size = cache_match.group(1)

			# Pick up the last CPU
			if cpu is not None and cpu not in procs:
				procs[cpu] = { 'model': model, 'cores': cpu_cores, 'cache': cache_size }

			if len(procs) > 0:
				cpu = str(len(procs)) + "x "
	
				if procs[0]['cores'] == 1:
					cpu = cpu + "single-core "
				elif procs[0]['cores'] == 2:
					cpu = cpu + "dual-core "
				elif procs[0]['cores'] == 4:
					cpu = cpu + "quad-core "
				elif procs[0]['cores'] == 8:
					cpu = cpu + "octa-core "
				else:
					cpu = cpu + str(procs[0]['cores']) + "-core "

				return cpu + procs[0]['model']

			else:
				return "Unknown CPU"

		except Exception as ex:
			return "Could not determine CPU information"

	############################################################################

	def system_get_sys(self):
		try:
			system_values = dmidecode.system().values()
		except Exception as ex:
			system_values = []

		vendor = ""
		try:
			for entry in system_values:
				if 'data' in entry:
					if 'Manufacturer' in entry['data']:
						vendor = entry['data']['Manufacturer']
						break
		except Exception as ex:
			pass

		model = ""
		try:
			for entry in system_values:
				if 'data' in entry:
					if 'Product Name' in entry['data']:
						model = entry['data']['Product Name']
						break
		except Exception as ex:
			pass

		return vendor + " " + model

	############################################################################

	def system_hwinfo(self):
		cpu = self.system_get_cpu()
		(memt,mem) = self.system_get_mem()
		gpu = self.system_get_gpu()
		sys = self.system_get_sys()

		print ANSI_BOLD + "SYS: " + ANSI_RESET + sys
		print ANSI_BOLD + "CPU: " + ANSI_RESET + cpu
		print ANSI_BOLD + "MEM: " + ANSI_RESET + mem
		print ANSI_BOLD + "GPU: " + ANSI_RESET + gpu

	############################################################################

	def system(self):
		if self.action == 'register':
			self.system_register()
		elif self.action == 'status':
			self.system_status()
		elif self.action == 'hwinfo':
			self.system_hwinfo()
		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################

	def ldi_event(self,hostname,api_key,server_url,event):
		server_url = server_url + "api/v1/event"

		self.print_debug("POSTing to " + server_url + " with hostname " + hostname)
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'event': event}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex("Unable to contact LDI server",ex)

		self.print_debug("return code " + str(r.status_code))

		if r.status_code == 200:
			self.print_verbose("LDI server acknowleged the event")
		else:
			self.fatal("unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def ldi_status(self,hostname,api_key,server_url):
		server_url = server_url + "api/v1/update/status"

		status_file = BASE_DIR + "/state/puppet"
		self.print_debug("Opening " + status_file)
		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					puppet_status = fp.read()
			except Exception as ex:
				self.fatalex("Could not read from puppet status file " + status_file,ex)
		else:
			self.fatal("Could not read puppet status file: file does not exist")

		self.print_debug("POSTing to " + server_url + " with hostname " + hostname)
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'type': 'puppet', 'data': puppet_status}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex("Unable to contact LDI server",ex)

		self.print_debug("return code " + str(r.status_code))

		if r.status_code == 200:
			self.print_verbose("LDI server accepted the puppet status update")
		else:
			self.fatal("unexpected HTTP return code from server: " + str(r.status_code))

		status_file = BASE_DIR + "/state/backup" 
		self.print_debug("Opening " + status_file)
		if os.path.exists(status_file):
			try:
				with open(status_file,"r") as fp:
					backup_status = fp.read()
			except Exception as ex:
				self.fatalex("Could not read from backup status file " + status_file,ex)

		self.print_debug("POSTing to " + server_url + " with hostname " + hostname)
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'type': 'backup', 'data': backup_status}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex("Unable to contact LDI server",ex)

		self.print_debug("return code " + str(r.status_code))

		if r.status_code == 200:
			self.print_verbose("LDI server accepted the backup status update")
		else:
			self.fatal("unexpected HTTP return code from server: " + str(r.status_code))

		## the update status is quite different. at the moment we just send 
		## back a json document just like the above two, but we just set the 
		## code output of the 'pkcon offline-get-prepared' command
		(code, output) = self.sysexec([self.config.get('update','pkcon_binary'), "offline-get-prepared"])

		update_status = { 'offline-get-prepared': int(code) }

		try:
			import yum

			base = yum.YumBase()
			logger = logging.getLogger("yum.verbose.YumPlugins")
			logger.setLevel(logging.CRITICAL)

			package_list = base.doPackageLists(pkgnarrow='updates', patterns='', ignore_case=True)

			if package_list.updates:
				update_status['yum_updates'] = len(package_list.updates)
			else:
				update_status['yum_updates'] = 0
		except Exception as ex:
			update_status['yum_updates'] = -1

		update_status_json = json.dumps(update_status)

		self.print_debug("POSTing to " + server_url + " with hostname " + hostname)
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'type': 'update', 'data': update_status_json}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex("Unable to contact LDI server",ex)

		self.print_debug("return code " + str(r.status_code))

		if r.status_code == 200:
			self.print_verbose("LDI server accepted the software update status update")
		else:
			self.fatal("unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def ldi_metadata(self,hostname,api_key,server_url):
		"""metadata is a series of custom-generated bits of data about the 
		workstation that are not exposed via Puppet facts. True, we could write
		custom facts, but they would have to be in Ruby. Eww."""

		server_url = server_url + "api/v1/update/metadata"

		metadata = {}

		gpu = self.system_get_gpu()
		sys = self.system_get_sys()


		(memt, mem) = self.system_get_mem()
		metadata['hwinfo'] = {
			'cpu': self.system_get_cpu(),
			'mem': mem,
			'gpu': self.system_get_gpu(),
			'sys': self.system_get_sys(),
		}
		metadata['drone'] = {'version': VERSION}
		try:
			metadata['packages'] = str(subprocess.check_output(['rpm', '-qa'])).splitlines()
		except subprocess.CalledProcessError:
			pass

		metadata = json.dumps(metadata)

		self.print_debug("POSTing to " + server_url + " with hostname " + hostname)
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'metadata': metadata}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex("Unable to contact LDI server",ex)

		self.print_debug("return code " + str(r.status_code))

		if r.status_code == 200:
			self.print_verbose("LDI server accepted the metadata update")
		else:
			self.fatal("unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def ldi_facts(self,hostname,api_key,server_url):
		server_url = server_url + "api/v1/update/facts"

		(code, output) = self.sysexec([self.config.get('puppet','binary'), 'facts', 'find', '--render-as', 'json', '--modulepath', str(BASE_DIR) + '/puppet/modules/'])

		if code != 0:
			self.fatal("Could not retrieve facts: \n" + output)

		self.print_debug("POSTing to " + server_url + " with hostname " + hostname)
		try:
			payload = {'hostname': hostname, 'api_key': api_key, 'facts': output}
			r = requests.post(server_url, data=payload, verify = self.config.getboolean('server','verify'))
		except Exception as ex:
			self.fatalex("Unable to contact LDI server",ex)

		self.print_debug("return code " + str(r.status_code))

		if r.status_code == 200:
			self.print_verbose("LDI server accepted the facts update")
		else:
			self.fatal("unexpected HTTP return code from server: " + str(r.status_code))

	############################################################################

	def ldi(self):
		self.is_network_up(exit_if_down=True)

		hostname = platform.node()
		api_key = self.config.get('server','api_key')

		server_url = self.config.get('server','address')
		if not server_url.endswith("/"):
			server_url = server_url + "/"

		if self.action in ['startup','shutdown','ping']:
			self.ldi_event(hostname,api_key,server_url,self.action)

		elif self.action == 'status':
			self.ldi_status(hostname,api_key,server_url)

		elif self.action == 'metadata':
			self.ldi_metadata(hostname,api_key,server_url)

		elif self.action == 'facts':
			self.ldi_facts(hostname,api_key,server_url)

		else:
			print 'Unrecognised or missing action'
			self.parser.print_help()

	############################################################################

	def version(self):
		print "drone agent v" + VERSION

	############################################################################

	def main(self):
		## We must be root
		if not os.geteuid() == 0:
			self.fatal("You must be root to run this command")

		## Load the config
		self.get_config()

		## Deal with command line arguments
		functions = """Available functions/actions:

  puppet
    status    show the status of the last puppet apply
    sync      download the latest puppet ruleset
    apply     apply puppet policy to the system
    run       performs a 'sync' and then an 'apply'
    facts     show puppet facts about the system

  backup
    now       perform a backup of this system
    status    show the status of the last backup
    ifneeded  perform a backup of this system if the last backup attempt
              was over 12 hours ago. it is intended that you run this 
              when the system is finished starting up.
    disable   disables backups on this system
    enable    enables backups on this system (the default)

  update
    trigger   schedule an offline system update to occur at the next reboot
    history   show the result of the last offline update
    status    show the packages due to be updated (if any) at next reboot

  reskit
    update    update the contents of reskit software packages
    list      list installed reskit software packages

  system
    register  (re-)register this system
    status    shows the system backup, puppet and update status
    hwinfo    shows the hardware information of the system

  ldi
    startup   inform the LDI server that the system has just started up
    shutdown  inform the LDI server that the system is shutting down
    ping      inform the LDI server that the system is alive
    status    inform the LDI server of the system status
    metadata  inform the LDI server about the system hardware
    facts     inform the LDI server of our puppet facts

  version     shows the version of the drone agent
  status      an alias for 'drone system status'

"""

		self.parser = argparse.ArgumentParser(prog='drone',description='workstation management agent',epilog=functions,formatter_class=argparse.RawDescriptionHelpFormatter)
		self.parser.add_argument('function', metavar='function', type=str, help='the function to perform')
		self.parser.add_argument('action', metavar='action', type=str, help='the action to perform', nargs="?", default=None)
		self.parser.add_argument('subaction', metavar='subaction', type=str, help=argparse.SUPPRESS, nargs="?", default=None)
		self.parser.add_argument('-d', '--debug', action='store_true', help='turn on debugging output',dest='debug')
		self.parser.add_argument('-v', '--verbose', action='store_true', help='turn on verbose output',dest='verbose')
		self.parser.add_argument('-i', '--ignore-nm-state', action='store_true', help="don't check with NetworkManager before using the network",dest='nmignore')

		self.args       = self.parser.parse_args()
		self.action     = self.args.action
		self.function   = self.args.function
		self.debug      = self.args.debug
		self.verbose    = self.args.verbose

		if self.function == 'puppet':
			self.puppet()
		elif self.function == 'backup':
			self.backup()
		elif self.function == 'update':
			self.update()
		elif self.function == 'reskit':
			self.reskit()
		elif self.function == 'system':
			self.system()
		elif self.function == 'ldi':
			self.ldi()
		elif self.function == 'version':
			self.version()
		elif self.function == 'help':
			self.parser.print_help()
		elif self.function == 'status':
			self.system_status()
		else:
			print 'Unrecognised function "' + self.function + '"'
			self.parser.print_help()

	############################################################################

if __name__ == "__main__":
	drone = DroneAgent()
	drone.main()
